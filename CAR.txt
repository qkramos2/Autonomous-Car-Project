/*
Program Name: CAR.c
 Description: Main program for TI Car Race Project
		 Authors: Quentin Ramos II & Robbie Riviere
--------------------------------------------------------------
Milestone #1 (DONE):
	- Drive car around oval

Milestone #2:
	- Drive car around figure 8

Milestone #3:
	- Drive car around custom track
		- Must be race speed
*/

//////////////////////////////////////////////////////////////
//
// TODO:
//	- Following Variables must be changed thru trial & error:
//		MIN_CARPET_COUNT 	(Camera.h)		set to: 63 	   (max = 64)
//		MIN_SPEED 			(DCMotors.h)	set to: 25.0   (max = 100)
//		DIFF_COEF			(DCMotors.h)	set to: 0.25   (max = 1)
//		MAX_TURN_THRESH		(CAR.c)			set to: 20     (max = max cam error = 25)
//		SERVO_STEP_SIZE		(CAR.c)			set to: 0.025  (max = 0.5)
//		TURN_THRESHOLD		(CAR.c)			set to: 1.0    (max = max cam error = 25)
//		CARPET_THRESHOLD	(CAR.c)			set to: 3	   (max = ∞)
//
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
// Include all necessary header files for the car:
//////////////////////////////////////////////////////////////

// Include standard C headers as well:

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Include all header files from past labs:

#include "Camera.h"
#include "Common.h"
#include "CortexM.h"
#include "DCMotors.h"
#include "LEDs.h"
#include "OLED.h"
#include "msp.h"
#include "PID.h"
#include "ServoMotor.h"
#include "StartMenu.h"
#include "Switches.h"
#include "UART.h"

//////////////////////////////////////////////////////////////
// --- DEFINES --- 
//////////////////////////////////////////////////////////////

// Turning Defines:
#define TURN_THRESHOLD 	 (5.000) 	// (Working:  1.50)
#define MAX_TURN_THRESH  (25.00)	// (Working:  20.0)
#define SERVO_STEP_SIZE	 (0.020)	// (Working: 0.025)

// Camera Defines:
#define CARPET_THRESHOLD (4)

//////////////////////////////////////////////////////////////
// --- VARIABLES --- 
//////////////////////////////////////////////////////////////

// Camera Variables:
extern BOOLEAN g_sendData;
extern uint16_t line[128];
uint16_t smoothData[128];

// OLED Variables:
extern unsigned char OLED_TEXT_ARR[1024];

// Start Menu Variables:
extern double setSpeed;		// Default: 0.0
extern int driveMode;		// Default: Drive Mode
extern int steerMode;		// Default: Bang-Bang

// Other Variables:
int skipStart = FALSE;
char str[100];

//////////////////////////////////////////////////////////////
//
// Initalize the car by enabling all motors & sensors and
//   enabling interrupts
//
//////////////////////////////////////////////////////////////

void initCar(void){

	// Disable Interrupts & Initalize:
	DisableInterrupts();

	// Initalize Motors & Camera:
	servoInit();
	DC_motors_init();
	enable_DCMotors();
	INIT_Camera();

	// Enable OLED:
	OLED_Init();
	OLED_display_on();
	OLED_display_clear();
	OLED_display_on();
	
	// Enable Switches & UART:
	LED1_Init();
	LED2_Init();
	Switch1_Init();
	Switch2_Init();
	uart0_init(SystemCoreClock);

	// Enable Interrupts and begin:
	EnableInterrupts();
}

//////////////////////////////////////////////////////////////
//
// set_steering function
//
// sets the steering angle based on the error from the
//  error calculation derived from the reference point.
//
//////////////////////////////////////////////////////////////
//
// Notes:
// 	Positive error = left || Negative error = right
//
// Servo Calculations:
// 	Servo turns 120° total | 60° each side
// 	1.0 to 2.0 = 120° | 0.5ms = 60° | 0.1ms = 12°
//
// Wheel Calculations:
// 	Wheel turns 60° total | 30° each side
// 	1.0 to 2.0 = 60° | 0.5ms = 30° | 0.1ms = 6°
//
// Threshold Value Calculations:
//	> SERVO_STEP_SIZE = 0.5ms / abs(error)
//	> MAX_TURN_THRESH = abs(max camera error)
//	> TURN_THRESHOLD  = <trial and error value> 
//
//////////////////////////////////////////////////////////////

void set_steering(double error){
	
	// If above turn threshold, turn the car:
	if (fabs(error) > TURN_THRESHOLD) {

		// Take a hard turn:
		if (fabs(error) >= MAX_TURN_THRESH) {
			// Determine left or right turn:
			toggleServo((error > 0) ? 2.0 : 1.0);
			differentialTurn(MAX_TURN_THRESH, MAX_TURN_THRESH, setSpeed);
		}

		// Turn approaching:
		else {
			// Determine left or right turn:
			toggleServo(1.5 + (SERVO_STEP_SIZE * error));
			differentialTurn(error, MAX_TURN_THRESH, setSpeed);
		}
		
	}
	
	// if below threshold keep going straight:
	else {
		toggleServo(1.5);
		differentialTurn(0.0, MAX_TURN_THRESH, setSpeed);
	}
}

//////////////////////////////////////////////////////////////
//
// miscellaneous functions:
//
//////////////////////////////////////////////////////////////

// millisecond delay:
void delay_ms(unsigned int milliseconds){
    for (unsigned int i = 0; i < milliseconds; i++) {
	for (unsigned int j = 0; j < 48000; j++) {}}
}

// Flash Red LED:
void redFlash(void){ LED2_On(RED); delay_ms(20); LED2_Off(RED); delay_ms(5); }

// Flash Green LED:
void greenFlash(void){ LED2_On(GREEN); delay_ms(20); LED2_Off(GREEN); delay_ms(5); }

// Wait 3 seconds and countdown each second on OLED:
void countDown(void){
	clear_OLED();
	OLED_Print(2,4,"3"); redFlash();
	OLED_Print(2,8,"2"); redFlash();
	OLED_Print(2,12,"1"); redFlash();
	OLED_Print(4,6,"RACE!"); greenFlash();
	clear_OLED();
}

//////////////////////////////////////////////////////////////
//
// Main Car Loop
//
//////////////////////////////////////////////////////////////

int main(void){

	int carpetCounter = 0;				// Carpet Detection Counter
	double error = 0.0;					// Error Value (Distance from center)
	int referenceADC = 0;				// Reference ADC Value
	double referenceTrackPosition = 0; 	// Reference Position
	
	// Skip initalization and restart countdown if restarting:
	if (!skipStart) { initCar(); startMenu(); }

	// Wait 3 seconds and countdown each second on OLED:
	countDown();

	// Set Reference Points once all 128 values come through on camera:

	/*
	// Dynamic Values:
	while (g_sendData == FALSE);

	data_smoother(line,smoothData);
	OLED_DisplayCameraData(smoothData);
	referenceTrackPosition = track_position(smoothData);		// Set the reference point (0-127)
	referenceADC = smoothData[(int) referenceTrackPosition];	// Obtain the reference ADC value (used for Carpet Detection)

	// Print references to UART if debug:
	if (driveMode == 1) {
		// Print the referenceTrackPosition to UART:
		sprintf(str, "Reference Track Position: %f", referenceTrackPosition);
		uart0_put(str); uart0_put("\n\r");
		// Print the referenceTrackPosition to UART:
		sprintf(str, "           Reference ADC: %d", referenceADC);
		uart0_put(str); uart0_put("\n\r");
	}
	else {
		toggleDCMotorsForward(setSpeed);
	}
	*/

	// Static Values:
	referenceTrackPosition = 64;
	referenceADC = 16300;

	// Infinitely loop:
	while(1) {

		if (g_sendData == TRUE){

			// Smoothen the data and display data on OLED:
			data_smoother(line,smoothData);
			OLED_DisplayCameraData(smoothData);

			// Calculate position in accordance to the reference:
			double current_pos = track_position(smoothData);

			// Calculate Error (0 = bang-bang | 1 = PID):
			if (steerMode == 1) {
				// Utilizng PID Controller:
				error = compute_pid(referenceTrackPosition, current_pos);
			}
			else {
				// Default Bang-Bang Method:
				error = referenceTrackPosition - current_pos;
			}
			
			// 0 = race mode (carpet detection) | 1 = debug mode:
			if (driveMode == 1) {
				// Print the error to UART:
				sprintf(str, "%f", error);
				uart0_put(str); uart0_put("\r");

				// steer the gawd dayum motor:
				// set_steering(error);
			}
			else {
				// if carpet counter is over threshold, stop the car:
				if (carpetCounter > CARPET_THRESHOLD) {
					stopDCMotors(); carpetCounter = 0;
					/*
					clear_OLED();
					OLED_Print(1,1,"< You fell off >");
					OLED_Print(2,1," Keep Settings? ");
					OLED_Print(3,1," -SW1/2- = Yes  ");
					OLED_Print(4,1," -Reset- = No   ");

					// If SW1/2 is pressed, reset servo and go again:
					while(1) { if(Switch1_Pressed() || Switch2_Pressed()){ 
						skipStart = TRUE; servoInit(); main();}
					}
					*/
				}
				// if carpet detected; keep turning in same direction to find track:
				else if (carpetDetection(smoothData, referenceADC) == 1) { 
					carpetCounter++; 
				}
				// steer the motor regularly and reset carpet counter:
				else { 
					set_steering(error); 
					carpetCounter = 0; 
				}
			}
		}
	}
}
